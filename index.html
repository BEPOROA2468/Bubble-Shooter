<!DOCTYPE html><html lang="bn">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rainbow Bubble Shooter ‚Äî Enhanced FX (Endless + Demo User + Ads)</title>
  <!-- Gigapub Ads Script (as provided) -->
  <script src="https://ad.gigapub.tech/script?id=1762"></script>
  <style>
    :root {
      --bg: #0b0f1d;
      --bg2: #0c1126;
      --panel: #141a31;
      --muted: #a3acc2;
      --accent: #7c5cff;
      --accent-2: #00e6a8;
      --danger: #ff6b6b;
      --gold: #ffd166;
      --ring: rgba(124,92,255,.45);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 50% -200px, #1b2142, var(--bg));
      color: #e6eaf6; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans";
      display: grid; grid-template-rows: auto 1fr auto; gap: 8px;
    }
    header {
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
      padding: 12px 16px; background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.15));
      border-bottom: 1px solid rgba(255,255,255,0.06);
      backdrop-filter: blur(6px);
      position: sticky; top: 0; z-index: 10;
    }
    header .brand { display:flex; align-items:center; gap: 10px; font-weight: 800; letter-spacing: .3px; }
    header .brand .dot { width: 10px; height: 10px; border-radius: 50%; background: conic-gradient(#ff5a91, #ffcd58, #7fff7c, #4ad9ff, #b38bff, #ff5a91); box-shadow: 0 0 10px #7c5cff; }
    .hud { display:flex; flex-wrap: wrap; gap: 8px; align-items:center; }
    .pill { padding: 6px 10px; background: var(--panel); border: 1px solid rgba(255,255,255,0.08); border-radius: 999px; color: var(--muted); font-size: 13px; }
    .pill strong { color: #fff; }
    .btn { cursor: pointer; padding: 8px 12px; border-radius: 10px; background: var(--accent); color: #fff; border: none; font-weight: 700; box-shadow: 0 6px 16px rgba(124,92,255,0.3); transition: transform .06s ease, box-shadow .2s ease, opacity .2s ease; }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 10px 22px rgba(124,92,255,0.4); }
    .btn.secondary { background: var(--panel); color: #e8ecff; border: 1px solid rgba(255,255,255,.08); box-shadow: none; }
    .btn.danger { background: var(--danger); box-shadow: 0 6px 16px rgba(255,107,107,0.25); }
    .btn.gold { background: var(--gold); color: #1b1b1b; box-shadow: 0 6px 16px rgba(255,209,102,0.3); }
    .btn[disabled] { opacity: .6; pointer-events: none; }main { display: grid; grid-template-columns: 1fr; place-items: center; padding: 8px 12px 16px; }
.game-shell { width: min(640px, 100%); aspect-ratio: 9/16; background: #0b0f1d; border: 1px solid rgba(255,255,255,0.08); border-radius: 16px; overflow: hidden; position: relative; box-shadow: 0 20px 60px rgba(0,0,0,.35); }
#gameCanvas { width: 100%; height: 100%; display: block; background: linear-gradient(180deg, var(--bg) 0%, var(--bg) 65%, var(--bg2) 100%); }

/* Overlay UI on canvas */
.overlay { position: absolute; inset: 0; pointer-events: none; }
.overlay .topbar { position: absolute; top: 8px; left: 8px; right: 8px; display:flex; justify-content: space-between; gap:8px; }
.overlay .topbar .stats { display:flex; gap:6px; flex-wrap: wrap; }
.overlay .topbar .stats .pill { pointer-events: auto; }
.overlay .bottombar { position: absolute; left: 8px; right: 8px; bottom: 8px; display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 8px; }
.overlay .bottombar .btn { pointer-events: auto; }
.toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px; padding: 10px 14px; background: #10152a; color: #eaf0ff; border: 1px solid rgba(255,255,255,.1); border-radius: 10px; box-shadow: 0 14px 26px rgba(0,0,0,.35); opacity: 0; pointer-events: none; transition: opacity .25s ease; z-index: 50; }
.toast.show { opacity: 1; }

dialog.modal { border: none; border-radius: 16px; width: min(480px, 92vw); background: #0f142b; color: #e7ecff; padding: 0; overflow: hidden; box-shadow: 0 24px 80px rgba(0,0,0,.6); }
dialog::backdrop { background: rgba(4,6,14,.6); backdrop-filter: blur(4px); }
.modal header { position: sticky; top: 0; background: #0f142b; border-bottom: 1px solid rgba(255,255,255,.06); padding: 14px 16px; }
.modal .content { padding: 16px; }
.field { display:grid; gap: 6px; margin: 10px 0 14px; }
.field input, .field select { padding: 10px 12px; background: #0c1228; color: #eaefff; border: 1px solid rgba(255,255,255,.08); border-radius: 10px; }
.row { display:flex; gap: 8px; align-items:center; }
.row > * { flex: 1; }
.muted { color: var(--muted); font-size: 13px; }

footer { padding: 10px 12px; text-align: center; color: var(--muted); font-size: 12px; }
a { color: var(--accent-2); text-decoration: none; }

  </style>
</head>
<body>
  <header>
    <div class="brand"><span class="dot"></span> Rainbow Bubble Shooter</div>
    <div class="hud">
      <div class="pill">User: <strong id="hudUser">Guest</strong></div>
      <div class="pill">Balance: <strong id="hudBalance">0</strong></div>
      <div class="pill">High Score: <strong id="hudHigh">0</strong></div>
      <button id="btnLogin" class="btn secondary">Demo User</button>
      <button id="btnWithdraw" class="btn secondary">Withdraw</button>
      <button id="btnMute" class="btn secondary">üîä Sound</button>
    </div>
  </header>  <main>
    <div class="game-shell" id="gameRoot">
      <canvas id="gameCanvas" width="720" height="1280"></canvas>
      <div class="overlay">
        <div class="topbar">
          <div class="stats">
            <div class="pill">Score: <strong id="scoreText">0</strong></div>
            <div class="pill">Shots: <strong id="shotsText">0</strong></div>
            <div class="pill">Level: <strong id="levelText">1</strong></div>
          </div>
          <button id="btnReset" class="btn danger">Reset</button>
        </div>
        <div class="bottombar">
          <button id="btnWatchAd" class="btn gold">üé• Watch Ad (Reward)</button>
          <button id="btnShoot" class="btn">Shoot</button>
          <button id="btnPause" class="btn secondary">Pause</button>
          <button id="btnAutoAim" class="btn secondary">Auto-Aim</button>
        </div>
      </div>
    </div>
  </main>  <footer>
    Endless demo game. The user system & withdraw here are for demonstration only ‚Äî no real money or payouts.
  </footer>  <div class="toast" id="toast"></div>  <!-- Modals -->  <dialog class="modal" id="loginModal">
    <header><strong>Demo User</strong></header>
    <div class="content">
      <p class="muted">‡¶è‡¶ü‡¶æ ‡¶ï‡ßá‡¶¨‡¶≤ ‡¶°‡ßá‡¶Æ‡ßã ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‚Äî LocalStorage ‡¶è ‡¶∏‡ßá‡¶≠ ‡¶π‡¶¨‡ßá‡•§</p>
      <div class="field">
        <label>Username</label>
        <input id="inpUsername" placeholder="e.g. player123" autocomplete="username" />
      </div>
      <div class="row">
        <button id="btnSaveUser" class="btn">Save</button>
        <button id="btnLogout" class="btn secondary">Logout</button>
      </div>
    </div>
  </dialog>  <dialog class="modal" id="withdrawModal">
    <header><strong>Demo Withdraw</strong></header>
    <div class="content">
      <p class="muted">‡¶°‡ßá‡¶Æ‡ßã ‡¶â‡¶¶‡ßç‡¶¶‡ßá‡¶∂‡ßç‡¶Ø‡ßá ‚Äî ‡¶Ü‡¶∏‡¶≤ ‡¶≤‡ßá‡¶®‡¶¶‡ßá‡¶® ‡¶®‡ßü‡•§
        ‡¶®‡ßç‡¶Ø‡ßÇ‡¶®‡¶§‡¶Æ ‡¶™‡¶∞‡¶ø‡¶Æ‡¶æ‡¶£ <strong>100</strong>‡•§ ‡¶∏‡¶´‡¶≤ ‡¶π‡¶≤‡ßá ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡¶æ‡¶®‡ßç‡¶∏ ‡¶•‡ßá‡¶ï‡ßá ‡¶ï‡¶æ‡¶ü‡¶æ ‡¶π‡¶¨‡ßá ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ï‡¶ü‡¶ø ‡¶´‡ßá‡¶á‡¶ï ‡¶ü‡ßç‡¶∞‡¶æ‡¶®‡ßç‡¶∏‡ßç‡¶Ø‡¶æ‡¶ï‡¶∂‡¶® ‡¶Ü‡¶á‡¶°‡¶ø ‡¶¶‡ßá‡¶ñ‡¶æ‡¶¨‡ßá‡•§</p>
      <div class="field">
        <label>Amount</label>
        <input id="inpAmount" type="number" min="1" step="1" placeholder="100" />
      </div>
      <div class="field">
        <label>Method</label>
        <select id="selMethod">
          <option value="bkash">bKash (Demo)</option>
          <option value="nagad">Nagad (Demo)</option>
          <option value="rocket">Rocket (Demo)</option>
        </select>
      </div>
      <div class="row">
        <button id="btnDoWithdraw" class="btn">Request</button>
        <button id="btnCancelWithdraw" class="btn secondary">Close</button>
      </div>
    </div>
  </dialog>  <script>
    // ======= Demo User System (LocalStorage) =======
    const storageKey = 'rbs_demo_user_v2';
    const user = { username: 'Guest', balance: 0, highScore: 0 };
    function loadUser() {
      try { const raw = localStorage.getItem(storageKey); if (raw) Object.assign(user, JSON.parse(raw)); } catch(e){}
      syncHud();
    }
    function saveUser() { try { localStorage.setItem(storageKey, JSON.stringify(user)); } catch(e){} syncHud(); }
    function syncHud() {
      document.getElementById('hudUser').textContent = user.username;
      document.getElementById('hudBalance').textContent = Math.floor(user.balance);
      document.getElementById('hudHigh').textContent = user.highScore;
    }

    // ======= Toast =======
    const toast = document.getElementById('toast');
    let toastTimer; function showToast(msg){ toast.textContent=msg; toast.classList.add('show'); clearTimeout(toastTimer); toastTimer=setTimeout(()=>toast.classList.remove('show'),2200); }

    // ======= Modals =======
    const loginModal = document.getElementById('loginModal');
    const withdrawModal = document.getElementById('withdrawModal');
    document.getElementById('btnLogin').addEventListener('click', () => loginModal.showModal());
    document.getElementById('btnWithdraw').addEventListener('click', () => withdrawModal.showModal());
    document.getElementById('btnSaveUser').addEventListener('click', () => { const name=document.getElementById('inpUsername').value.trim(); if(!name) return showToast('Username ‡¶¶‡¶ø‡¶§‡ßá ‡¶π‡¶¨‡ßá'); user.username=name; saveUser(); loginModal.close(); showToast('Demo user saved'); });
    document.getElementById('btnLogout').addEventListener('click', () => { user.username='Guest'; user.balance=0; saveUser(); loginModal.close(); showToast('Logged out'); });
    document.getElementById('btnCancelWithdraw').addEventListener('click', () => withdrawModal.close());
    document.getElementById('btnDoWithdraw').addEventListener('click', () => {
      const amt=parseInt(document.getElementById('inpAmount').value||'0',10);
      if(isNaN(amt)||amt<=0) return showToast('‡¶∏‡¶†‡¶ø‡¶ï Amount ‡¶¶‡¶ø‡¶®');
      if(amt<100) return showToast('‡¶®‡ßç‡¶Ø‡ßÇ‡¶®‡¶§‡¶Æ 100');
      if(user.balance<amt) return showToast('‡¶™‡¶∞‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶§ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡¶æ‡¶®‡ßç‡¶∏ ‡¶®‡ßá‡¶á');
      user.balance-=amt; saveUser(); const method=document.getElementById('selMethod').value; const tx='TX-'+Math.random().toString(36).slice(2,8).toUpperCase(); withdrawModal.close(); showToast(`Withdraw (DEMO) ${method} ‚Üí ${amt}. Ref: ${tx}`);
    });

    // ======= Simple WebAudio Synth (shoot/pop/music) =======
    let AC, masterGain, musicGain, muted=false, musicNodes=[];
    function ensureAudio() {
      if (AC) return; AC = new (window.AudioContext||window.webkitAudioContext)();
      masterGain = AC.createGain(); masterGain.gain.value = 0.6; masterGain.connect(AC.destination);
      musicGain = AC.createGain(); musicGain.gain.value = 0.15; musicGain.connect(masterGain);
      startMusic();
    }
    function clickResumeAudio(){ if (AC && AC.state==='suspended') AC.resume(); }
    function playBeep(freq=600, dur=0.08, type='square'){ if (muted) return; ensureAudio(); const o=AC.createOscillator(); const g=AC.createGain(); o.type=type; o.frequency.value=freq; g.gain.setValueAtTime(0.001, AC.currentTime); g.gain.exponentialRampToValueAtTime(0.4, AC.currentTime+0.01); g.gain.exponentialRampToValueAtTime(0.001, AC.currentTime+dur); o.connect(g); g.connect(masterGain); o.start(); o.stop(AC.currentTime+dur+0.02); }
    function playShoot(){ playBeep(720,0.09,'triangle'); }
    function playPop(size=3){ // layered pops
      for(let i=0;i<size;i++){ setTimeout(()=>playBeep(380+Math.random()*120,0.06,'square'), i*20); }
    }
    function startMusic(){ if (muted) return; if (!AC) ensureAudio(); stopMusic();
      // Tiny ambient pad using 3 detuned oscillators + slow filter LFO
      const freqs=[196, 246.94, 293.66]; // G3, B3, D4 (G major)
      const now=AC.currentTime; const filter=AC.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value=800; filter.Q.value=0.2; filter.connect(musicGain);
      freqs.forEach((f,idx)=>{ const o=AC.createOscillator(); o.type='sine'; o.frequency.value=f; const g=AC.createGain(); g.gain.value=0.0001; g.gain.linearRampToValueAtTime(0.15/(idx+1), now+3); o.detune.value = (idx-1)*3; o.connect(g); g.connect(filter); o.start(); musicNodes.push(o,g); });
      // slow cutoff wobble
      const lfo=AC.createOscillator(); lfo.frequency.value=0.08; const lfoGain=AC.createGain(); lfoGain.gain.value=220; lfo.connect(lfoGain); lfoGain.connect(filter.frequency); lfo.start(); musicNodes.push(lfo,lfoGain,filter);
    }
    function stopMusic(){ if(!AC) return; while(musicNodes.length){ const n=musicNodes.pop(); try{ if(n.stop) n.stop(); if(n.disconnect) n.disconnect(); }catch(e){} } }
    function setMuted(v){ muted=v; document.getElementById('btnMute').textContent = v?'üîà Muted':'üîä Sound'; if(v){ stopMusic(); } else { ensureAudio(); startMusic(); } }
    document.getElementById('btnMute').addEventListener('click', ()=>{ setMuted(!muted); showToast(muted?'Sound off':'Sound on'); });

    // ======= Gigapub Ads Integration =======
    const REWARD_PER_AD = 10; // coins per ad
    const watchBtn = document.getElementById('btnWatchAd');
    watchBtn.addEventListener('click', async () => {
      ensureAudio(); clickResumeAudio();
      if (!window.showGiga) { showToast('Ad SDK not ready'); return; }
      watchBtn.disabled = true; watchBtn.textContent = 'Loading ad...';
      try {
        await window.showGiga();
        user.balance += REWARD_PER_AD; saveUser();
        playBeep(520,0.12,'sine');
        showToast(`Ad watched ‚úì +${REWARD_PER_AD} coins`);
      } catch (e) { console.warn(e); showToast('Ad failed or canceled'); }
      finally { watchBtn.disabled = false; watchBtn.textContent = 'üé• Watch Ad (Reward)'; }
    });

    // ======= Game: Rainbow Bubble Shooter (Endless + FX) =======
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const root = document.getElementById('gameRoot');

    // Responsive canvas
    function fitCanvas(){ const r=root.getBoundingClientRect(); const dpr=Math.min(window.devicePixelRatio||1, 2); canvas.width=Math.floor(r.width*dpr); canvas.height=Math.floor(r.height*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
    new ResizeObserver(fitCanvas).observe(root); window.addEventListener('orientationchange', ()=>setTimeout(fitCanvas,250));

    // Game constants
    const COLORS = ['#ff7675', '#74b9ff', '#55efc4', '#ffeaa7', '#a29bfe', '#fd79a8'];
    const ROW_HEIGHT = 34; const BUBBLE_R = 16; const COLS = 12; const TOP_MARGIN = 10; const SHOOT_SPEED = 9.5; const ADD_ROW_EVERY = 6;

    // State
    let grid=[]; let score=0, shots=0, level=1; let nextColor=randColor();
    let shooter={x:0,y:0}; let aimAngle=-Math.PI/2; let ball=null; let paused=false; let autoAim=false;

    // Particles for pop
    const particles=[]; // {x,y,vx,vy,life,color}

    function spawnParticles(x,y,color,count=12){
      for(let i=0;i<count;i++){
        const a=Math.random()*Math.PI*2; const s=2+Math.random()*3;
        particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:28+Math.random()*12,color});
      }
    }

    function stepParticles(){
      for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.06; p.life--; if(p.life<=0) particles.splice(i,1); }
    }
    function drawParticles(){
      particles.forEach(p=>{ ctx.globalAlpha=Math.max(0, p.life/40); ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,2.2,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; });
    }

    // Grid helpers
    function randColor(){ return COLORS[(Math.random()*COLORS.length)|0]; }
    function createRow(offsetOdd){ return new Array(COLS-(offsetOdd?1:0)).fill(null); }
    function initGrid(){ grid=[]; const startRows=8; for(let r=0;r<startRows;r++){ const odd=r%2===1; const row=createRow(odd).map(()=>({color:randColor()})); grid.push(row);} score=0; shots=0; level=1; nextColor=randColor(); updateHudTexts(); }
    function addRowAtTop(){ const row=createRow(false).map(()=>({color:randColor()})); grid.unshift(row); level++; }
    function addRowAtBottomEmpty(){ const idx=grid.length; grid.push(createRow(idx%2===1)); }

    function gridToXY(row,col){ const odd=row%2===1; const x0=12+(odd?BUBBLE_R:0); const x=x0+col*(BUBBLE_R*2); const y=TOP_MARGIN+row*ROW_HEIGHT; return {x,y}; }
    function xyToGrid(x,y){ let row=Math.max(0, Math.round((y-TOP_MARGIN)/ROW_HEIGHT)); row=Math.min(row, grid.length); const odd=row%2===1; const x0=12+(odd?BUBBLE_R:0); let col=Math.round((x-x0)/(BUBBLE_R*2)); const colsInRow=COLS-(odd?1:0); col=Math.max(0, Math.min(colsInRow-1, col)); return {row,col}; }

    // BFS cluster
    function findCluster(row,col){ const start=grid[row]&&grid[row][col]; if(!start) return []; const color=start.color; const v=new Set(); const q=[[row,col]], out=[]; const key=(r,c)=>r+','+c; while(q.length){ const [r,c]=q.shift(); const cell=grid[r]&&grid[r][c]; if(!cell||cell.color!==color) continue; const k=key(r,c); if(v.has(k)) continue; v.add(k); out.push([r,c]); const odd=r%2===1; const neigh=[[r,c-1],[r,c+1],[r-1,c-(odd?0:1)],[r-1,c+(odd?1:0)],[r+1,c-(odd?0:1)],[r+1,c+(odd?1:0)]]; for(const [nr,nc] of neigh){ if(nr>=0&&nr<grid.length){ const colsInRow=COLS-(nr%2===1?1:0); if(nc>=0&&nc<colsInRow) q.push([nr,nc]); } } } return out; }
    function removeCells(list){ for(const [r,c] of list){ if(grid[r]&&grid[r][c]){ const {x,y}=gridToXY(r,c); spawnParticles(x,y,grid[r][c].color,14); grid[r][c]=null; } } }
    function dropOrphans(){ const v=new Set(); const key=(r,c)=>r+','+c; const q=[]; if(grid.length){ for(let c=0;c<grid[0].length;c++) if(grid[0][c]) q.push([0,c]); } while(q.length){ const [r,c]=q.shift(); const k=key(r,c); if(v.has(k)) continue; v.add(k); const odd=r%2===1; const neigh=[[r,c-1],[r,c+1],[r-1,c-(odd?0:1)],[r-1,c+(odd?1:0)],[r+1,c-(odd?0:1)],[r+1,c+(odd?1:0)]]; for(const [nr,nc] of neigh){ if(nr>=0&&nr<grid.length){ const colsInRow=COLS-(nr%2===1?1:0); if(nc>=0&&nc<colsInRow&&grid[nr][nc]) q.push([nr,nc]); } } }
      let dropped=0; for(let r=0;r<grid.length;r++){ for(let c=0;c<grid[r].length;c++){ if(grid[r][c]&&!v.has(r+','+c)){ const {x,y}=gridToXY(r,c); spawnParticles(x,y,grid[r][c].color,10); grid[r][c]=null; dropped++; } } } return dropped; }

    // Drawing
    function shade(col, amt){ const c=col.replace('#',''); const r=Math.max(0,Math.min(255,parseInt(c.slice(0,2),16)+amt)); const g=Math.max(0,Math.min(255,parseInt(c.slice(2,4),16)+amt)); const b=Math.max(0,Math.min(255,parseInt(c.slice(4,6),16)+amt)); return '#' + [r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); }
    function drawBubble(x,y,color,stroke=true){ ctx.beginPath(); ctx.arc(x,y,BUBBLE_R,0,Math.PI*2); const grd=ctx.createRadialGradient(x-6,y-6,4,x,y,BUBBLE_R); grd.addColorStop(0,'#ffffff'); grd.addColorStop(0.12,color); grd.addColorStop(1,shade(color,-20)); ctx.fillStyle=grd; ctx.fill(); if(stroke){ ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.lineWidth=1; ctx.stroke(); }
      // soft bloom ring
      ctx.beginPath(); ctx.arc(x,y,BUBBLE_R+6,0,Math.PI*2); ctx.strokeStyle= 'rgba(255,255,255,.04)'; ctx.lineWidth=4; ctx.stroke();
    }
    function drawGrid(){ for(let r=0;r<grid.length;r++){ const odd=r%2===1; const colsInRow=COLS-(odd?1:0); for(let c=0;c<colsInRow;c++){ const cell=grid[r][c]; if(!cell) continue; const {x,y}=gridToXY(r,c); drawBubble(x,y,cell.color); } } }
    function drawShooter(){ const baseY=canvas.height/(window.devicePixelRatio||1)-80; const baseX=canvas.width/(window.devicePixelRatio||1)/2; shooter.x=baseX; shooter.y=baseY; // barrel
      ctx.save(); ctx.translate(baseX, baseY); ctx.rotate(aimAngle+Math.PI/2); ctx.fillStyle='#222a54'; ctx.beginPath(); ctx.roundRect(-10,-46,20,48,10); ctx.fill(); ctx.restore();
      // base
      ctx.fillStyle='#1d2444'; ctx.beginPath(); ctx.roundRect(baseX-40, baseY+24, 80, 22, 11); ctx.fill();
      // next bubble preview
      drawBubble(baseX+60, baseY+6, nextColor);
    }

    function drawAimDots(){ if(ball) return; const W=canvas.width/(window.devicePixelRatio||1); let x=shooter.x, y=shooter.y; let vx=Math.cos(aimAngle)*10, vy=Math.sin(aimAngle)*10; ctx.save(); ctx.globalAlpha=0.25; for(let i=0;i<60;i++){ x+=vx; y+=vy; if(x<BUBBLE_R+8 && vx<0) vx*=-1; if(x>W-(BUBBLE_R+8) && vx>0) vx*=-1; ctx.beginPath(); ctx.arc(x,y,2.4,0,Math.PI*2); ctx.fillStyle='#ffffff'; ctx.fill(); if(y<TOP_MARGIN+BUBBLE_R+6) break; } ctx.restore(); }

    function updateHudTexts(){ document.getElementById('scoreText').textContent=score; document.getElementById('shotsText').textContent=shots; document.getElementById('levelText').textContent=level; }

    // Ball physics
    function spawnBall(angle){ if(ball) return; ensureAudio(); clickResumeAudio(); playShoot(); const speed=SHOOT_SPEED; ball={ x:shooter.x, y:shooter.y, vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, color:nextColor };
      nextColor=randColor(); shots++; if(shots%ADD_ROW_EVERY===0) addRowAtTop(); updateHudTexts(); }
    function reflectWalls(){ const W=canvas.width/(window.devicePixelRatio||1); if(!ball) return; if(ball.x<BUBBLE_R+8 && ball.vx<0) ball.vx*=-1; if(ball.x>W-(BUBBLE_R+8) && ball.vx>0) ball.vx*=-1; }
    function stepBall(){ if(!ball) return; ball.x+=ball.vx; ball.y+=ball.vy; reflectWalls(); if(ball.y<=TOP_MARGIN+BUBBLE_R){ stickBallAt(ball.x, ball.y); return; }
      // hit test against bubbles
      outer: for(let r=0;r<grid.length;r++){ const odd=r%2===1; const colsInRow=COLS-(odd?1:0); for(let c=0;c<colsInRow;c++){ const cell=grid[r][c]; if(!cell) continue; const {x,y}=gridToXY(r,c); const dx=x-ball.x, dy=y-ball.y; const dist=Math.hypot(dx,dy); if(dist<=BUBBLE_R*2-0.5){ const snap=xyToGrid(ball.x, ball.y); placeAndResolve(snap.row, snap.col); break outer; } } }
      // bottom bounce safeguard
      const H=canvas.height/(window.devicePixelRatio||1); if(ball && ball.y>H-40){ ball.vy=-Math.abs(ball.vy); }
    }

    function stickBallAt(x,y){ const s=xyToGrid(x,y); placeAndResolve(s.row,s.col); }
    function placeAndResolve(row,col){ while(row>=grid.length) addRowAtBottomEmpty(); if(!grid[row][col]) grid[row][col]={color:ball.color}; const placedColor=ball.color; ball=null; const cluster=findCluster(row,col); if(cluster.length>=3){ removeCells(cluster); const dropped=dropOrphans(); const gained=cluster.length*6 + dropped*9; score+=gained; user.balance+=Math.floor(gained/5); if(score>user.highScore) user.highScore=score; saveUser(); updateHudTexts(); playPop(Math.min(5,cluster.length)); showToast(`Pop ${cluster.length}${dropped?` + Drop ${dropped}`:''} ‚Üí +${gained}`); }
      // Endless pressure control
      const H=canvas.height/(window.devicePixelRatio||1); const bottomY=TOP_MARGIN+grid.length*ROW_HEIGHT+BUBBLE_R; if(bottomY>H-120){ grid.pop(); showToast('Pressure ‚Üë (Endless)'); }
      // little sparkle on place
      const {x,y}=gridToXY(row,col); spawnParticles(x,y,placedColor,8);
    }

    // Input handling
    function setAimFromPoint(px,py){ const rect=canvas.getBoundingClientRect(); const cx=(px-rect.left); const cy=(py-rect.top); const dx=cx-shooter.x; const dy=cy-shooter.y; aimAngle=Math.atan2(dy,dx); const minA=(-Math.PI+0.2), maxA=(-0.2); if(aimAngle<minA) aimAngle=minA; if(aimAngle>maxA) aimAngle=maxA; }
    canvas.addEventListener('mousemove', e=>setAimFromPoint(e.clientX,e.clientY));
    canvas.addEventListener('mousedown', ()=>spawnBall(aimAngle));
    canvas.addEventListener('touchstart', e=>{ const t=e.changedTouches[0]; setAimFromPoint(t.clientX,t.clientY); spawnBall(aimAngle); }, {passive:true});
    canvas.addEventListener('touchmove', e=>{ const t=e.changedTouches[0]; setAimFromPoint(t.clientX,t.clientY); }, {passive:true});

    // Buttons
    document.getElementById('btnShoot').addEventListener('click', ()=>spawnBall(aimAngle));
    document.getElementById('btnPause').addEventListener('click', (ev)=>{ paused=!paused; ev.target.textContent=paused?'Resume':'Pause'; });
    document.getElementById('btnReset').addEventListener('click', ()=>{ initGrid(); saveUser(); showToast('Reset'); });
    document.getElementById('btnAutoAim').addEventListener('click', (ev)=>{ autoAim=!autoAim; ev.target.textContent=autoAim?'Auto-Aim ‚úì':'Auto-Aim'; });

    // Auto-aim: pick nearest same color in top half
    function autoAimAngle(){ const targetColor=nextColor; let best=null, bestD=1e9; for(let r=0;r<grid.length;r++){ for(let c=0;c<grid[r].length;c++){ const cell=grid[r][c]; if(!cell||cell.color!==targetColor) continue; const {x,y}=gridToXY(r,c); const d=(x-shooter.x)**2+(y-shooter.y)**2; if(d<bestD){ bestD=d; best={x,y}; } } } if(!best) return -Math.PI/2; return Math.atan2(best.y-shooter.y, best.x-shooter.x); }

    function render(){ ctx.clearRect(0,0,canvas.width,canvas.height); const W=canvas.width/(window.devicePixelRatio||1), H=canvas.height/(window.devicePixelRatio||1); // bg
      const grad=ctx.createLinearGradient(0,0,0,H); grad.addColorStop(0,'#0b0f1d'); grad.addColorStop(1,'#0c1124'); ctx.fillStyle=grad; ctx.fillRect(0,0,W,H);
      // glowing ceiling
      const g=ctx.createLinearGradient(0,0,0,40); g.addColorStop(0,'rgba(124,92,255,.45)'); g.addColorStop(1,'rgba(124,92,255,0)'); ctx.fillStyle=g; ctx.fillRect(0,0,W,40);
      drawGrid(); if(ball) drawBubble(ball.x,ball.y,ball.color,true); drawParticles(); drawShooter(); drawAimDots(); }

    function loop(){ if(!paused){ if(autoAim) aimAngle=autoAimAngle(); stepBall(); stepParticles(); render(); } requestAnimationFrame(loop); }

    function updateHud(){ document.getElementById('scoreText').textContent=score; document.getElementById('shotsText').textContent=shots; document.getElementById('levelText').textContent=level; }

    // Start
    fitCanvas(); initGrid(); loadUser(); updateHud(); loop();
  </script></body>
</html>
